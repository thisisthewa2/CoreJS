## 01. 상황에 따라 달라지는 this
this는 실행 컨텍스트가 생성될 때 결정 된다. 실행 컨텍스트는 함수를 호출할 때 생성되므로 **this는 함수를 호출할 때 결정된다**


### 전역 공간에서의 this
전역 공간에서 this는 전역 객체를 가리킴. 개념상 전역 컨텍스트를 생성하는 주체가 바로 전역 객체이기 때문. 
브라우저 환경에서 전역 객체는 window이고 node.js에서는 global이다.

**자바스크립트의 모든 변수는 특정 객체의 프로퍼티**로 동작한다.

여기서 특정 객체라 함은 실행컨텍스트의 LexicalEnvironment이다. 
실행 컨텍스트는 변수를 수집해서 L.E의 프로퍼티로 저장한뒤 변수를 호출하면 L.E를 조회해서 일치하는 프로퍼티가 있을 경우 그 값을 반환한다.
전역 컨텍스트의 경우 L.E는 전역객체를 그대로 참조한다. 그래서 **전역 변수를 선언하면 자바스크립트 엔진은 이를 전역 객체의 프로퍼티로도 할당한다.** 
따라서 window.a와 같이 사용할 수도 있다.

변수 a를 직접 호출할 수 있는 이유
스코프 체인에서 a를 검색하다 가장 마지막에 도달하는 전역 스코프의 L.E, 전역 객체에서 해당 프로퍼티 a를 발견해서 그 값을 반환하기 때문

### 메서드로서 호출할 때 그 메서드 내부에서의 this
#### 함수 vs 메서드
함수로서의 호출: 앞에 점/대괄호 이 없음.
메서드로서의 호출: 앞에 점/대괄호 이 있음.
어떤 함수를 호출할 때 함수 이름 앞에 객체가 명시되어 있다면 메서드 호출, 아니라면 함수 호출

#### 메서드 내부에서의 this
메서드 호출할 때 this = 함수 명 앞의 객체

### 함수로서 호출할 때 그 함수 내부에서의 this
#### 함수 내부에서의 this
어떤 함수를 함수로서 호출할 경우 this가 지정되지 않음.

#### 생성자 함수 내부에서의 this
생성자는 구체적인 인스턴스를 만들기 위한 일종의 틀이다. 
해당 클래스의 공통 속성들이 미리 준비돼 있고, 여기에 구체적인 인스턴스의 개성을 더해 개별 인스턴스를 만들 수 있다.

자바스크립트는 **new**명령어와 함께 함수를 호출하면 해당 함수가 생성자로서 동작한다.

```
var Cat = function (name, age) {
    this.bark = '야옹';
    this.name = name;
    this.age = age;
};

var choco = new Cat('초코',7);
var nabi = new Cat('나비',5);

/*
결과
Cat {bark: '야옹', name: 초코, age: 7}
Cat {bark: '야옹', name: 나비, age: 75
*/
```
## 명시적으로 this를 바인딩하는 방법
### call 메서드
Function.prototype.call(thisArg[, arg1[, arg2[, ...]]])
call 메서드는 메서드의 호출 주체인 함수를 즉시 실행하도록 하는 명령
이때 call메서드의 첫번째 인자를 this로 바인딩하고, 이후의 인자들을 호출할 함수의 매개변수로 함.
```
var func = function (a,b,c) {
  cosole.log(this, a, b, c);
}

func(1,2,3); //Window{...},1 2 3
func.call({x:1}, 4,5,6); // {x:1} 4 5 6
```
### 화살표 함수의 예외사항
화상표 함수는 실행 컨텍스트 생성 시 this를 바인딩하는 과정이 제외되어 this에 접근하면 스코프체인 상 가장 가까운 this에 접근하기 됨.

### 별도의 인자로 this를 받는 경우(콜백함수 내에서의 this)
콜백함수를 인자로 받는 메서드 중 일부는 추가로 this로 지정할 객체를 인자로 지정할 수 있는 경우가 있다.
이언 령태는 여러 내부 요소에 같은 동작을 반복 수행해야 하는 배열 메서드에 많이 포진되어 있다.
